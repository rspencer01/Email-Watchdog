#!/usr/bin/env python3

import sys
import imaplib
import hashlib
import datetime
import email
import mailparser
import logging
import json
import yaml
import extruct

import argparse
import telegram
import time

from tzlocal import get_localzone
from bs4 import BeautifulSoup

from icalendar import Calendar, Event
import caldav

from Notification import Notification
from FlightEvent import FlightEvent
from LodgingEvent import LodgingEvent
from RestaurantEvent import RestaurantEvent
from Appointment import Appointment

from process_mail import *

config = yaml.full_load(open("config.yaml"))

parser = argparse.ArgumentParser()
parser.add_argument("--inbox-only", action="store_true")

args = parser.parse_args()

client = caldav.DAVClient(
    "https://{username}:{password}@{url}".format(**config["calendars"][0])
)
principal = client.principal()
calendars = principal.calendars()
personal_calendar = [i for i in calendars if i.name == config["calendars"][0]["name"]][
    0
]

previous_dates = {}

try:
    check_since = datetime.datetime.strptime(
        open("last").read().strip(), "%d-%m-%Y %H:%M:%S"
    )
except:
    check_since = datetime.datetime.now() - datetime.timedelta(days=1000)
open("last", "w").write(datetime.datetime.now().strftime("%d-%m-%Y %H:%M:%S"))
try:
    seen = set(map(lambda x: x.strip(), open("seen").readlines()))
except:
    seen = set()


logging.basicConfig(filename="emailparser.log", level=logging.INFO)
logFormatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s: %(message)s")
consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(logFormatter)
consoleHandler.setLevel(logging.WARN)
logging.getLogger().addHandler(consoleHandler)
logf = logging.getLogger()


bot = telegram.Bot(token=config["telegram"]["token"])

res = []
for email_account in config["email_accounts"]:
    with imaplib.IMAP4_SSL(email_account["server"]) as M:
        M.login(email_account["username"], email_account["password"])
        if args.inbox_only:
            mailboxes = ["INBOX"]
        else:
            r, mailboxes = M.list()
            if r != "OK":
                logf.error("No mailboxes")
                exit(1)
            mailboxes = [mb.decode("utf-8").split(' "/" ')[1] for mb in mailboxes]
        logf.info("Checking mailboxes {}".format(mailboxes))
        for mailbox in mailboxes:
            logf.info("Checking mailbox {}".format(mailbox))
            resp, _ = M.select(mailbox, readonly=True)
            if resp != "OK":
                logf.warn(
                    "Could not select mailbox %s in account %s",
                    mailbox,
                    email_account["name"],
                )
                continue
            r, data = M.search(
                None, '(SINCE "{}")'.format(check_since.strftime("%d-%b-%Y"))
            )
            for message_uid in data[0].decode("utf-8").split():
                cd = "{}/{}/{}".format(email_account["name"], mailbox, message_uid)
                if cd in seen:
                    continue
                open("seen", "a").write("\n" + cd)
                r, data = M.fetch(message_uid, "(RFC822)")
                try:
                    em = mailparser.parse_from_bytes(data[0][1])
                except:
                    continue
                res += process_mail(em)


def get_response():
    updates = bot.getUpdates(allowed_updates=["callback_query"])
    if updates != []:
        next_id = updates[-1].update_id + 1
    else:
        next_id = None
    while True:
        try:
            updates = bot.getUpdates(
                offset=next_id, timeout=10, allowed_updates=["callback_query"]
            )
        except telegram.error.TimedOut:
            continue
        if updates != []:
            return updates


menu = [
    [telegram.InlineKeyboardButton(text="Yes, please.", callback_data="yes")],
    [telegram.InlineKeyboardButton(text="No, thank you.", callback_data="no")],
]
reply_markup = telegram.InlineKeyboardMarkup(menu)
for r in res:
    t = r.telegram()
    if t is None:
        continue
    message_id = bot.sendMessage(
        chat_id=config["telegram"]["chat_id"],
        text=t,
        reply_markup=reply_markup,
        parse_mode=telegram.ParseMode.MARKDOWN,
    ).message_id
    response = get_response()[-1]
    bot.answerCallbackQuery(response.callback_query.id)
    bot.editMessageReplyMarkup(
        chat_id=config["telegram"]["chat_id"],
        message_id=message_id,
        reply_markup=telegram.InlineKeyboardMarkup([[]]),
    )
    if response.callback_query.data == "yes":
        personal_calendar.add_event(r.ical())
    else:
        pass
