#!/usr/bin/env python3

import sys
import imaplib
import hashlib
import datetime
import email
import mailparser
import logging
import json
import yaml
import extruct

import dateutil.parser
import dateparser

import argparse
import telegram
import time

from tzlocal import get_localzone
from bs4 import BeautifulSoup

from icalendar import Calendar, Event
import caldav

from Notification import Notification
from FlightEvent import FlightEvent
from LodgingEvent import LodgingEvent
from RestaurantEvent import RestaurantEvent

config = yaml.full_load(open("config.yaml"))

parser = argparse.ArgumentParser()
parser.add_argument("--inbox-only", action="store_true")

args = parser.parse_args()

client = caldav.DAVClient(
    "https://{username}:{password}@{url}".format(**config["calendars"][0])
)
principal = client.principal()
calendars = principal.calendars()
personal_calendar = [i for i in calendars if i.name == config["calendars"][0]["name"]][
    0
]

previous_dates = {}

try:
    check_since = datetime.datetime.strptime(
        open("last").read().strip(), "%d-%m-%Y %H:%M:%S"
    )
except:
    check_since = datetime.datetime.now() - datetime.timedelta(days=1000)
open("last", "w").write(datetime.datetime.now().strftime("%d-%m-%Y %H:%M:%S"))


logging.basicConfig(filename="emailparser.log", level=logging.DEBUG)
logFormatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s: %(message)s")
consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(logFormatter)
consoleHandler.setLevel(logging.INFO)
logging.getLogger().addHandler(consoleHandler)
logf = logging.getLogger()


def parsedate_simple(s):
    if s == "":
        return ""

    return dateutil.parser.parse(s)


def traverse(scm, path):
    if "properties" in scm and type(scm["properties"]) == dict:
        return traverse(scm["properties"], path)
    if len(path) == 1:
        return scm.get(path[0], "")
    return traverse(scm.get(path[0], {}), path[1:])


def process_schema(mail):
    reservations = []
    for t in mail.text_html:
        schemas = extruct.extract(t)
        for scm in schemas["microdata"]:
            if scm["type"] == "http://schema.org/EmailMessage":
                pass
            elif scm["type"] == "http://schema.org/FlightReservation":
                reservations.append(
                    FlightEvent(
                        reservation_number=traverse(scm, ["reservationNumber"]),
                        flight_number=traverse(
                            scm, ["reservationFor", "airline", "iataCode"]
                        )
                        + traverse(scm, ["reservationFor", "flightNumber"]),
                        departure_airport_code=traverse(
                            scm, ["reservationFor", "departureAirport", "iataCode"]
                        ),
                        arrival_airport_code=traverse(
                            scm, ["reservationFor", "arrivalAirport", "iataCode"]
                        ),
                        departure_airport_name=traverse(
                            scm, ["reservationFor", "departureAirport", "name"]
                        ),
                        arrival_airport_name=traverse(
                            scm, ["reservationFor", "arrivalAirport", "name"]
                        ),
                        departure_time=parsedate_simple(
                            traverse(scm, ["reservationFor", "departureTime"])
                        ),
                        arrival_time=parsedate_simple(
                            traverse(scm, ["reservationFor", "arrivalTime"])
                        ),
                    )
                )
            else:
                reservations.append(
                    Notification(
                        "Unknown schema type, {}.  Is it interesting?".format(
                            scm.get("type", "NONE")
                        )
                    )
                )
        for scm in schemas["json-ld"]:
            if scm.get("@type", "") == "EmailMessage":
                pass
            elif scm.get("@type", "") == "LodgingReservation":
                reservations.append(
                    LodgingEvent(
                        reservation_number=traverse(scm, ["reservationNumber"]),
                        lodging_name=traverse(scm, ["reservationFor", "name"]),
                        lodging_address=traverse(
                            scm, ["reservationFor", "address", "streetAddress"]
                        ),
                        check_in=parsedate_simple(traverse(scm, ["checkinDate"])),
                        check_out=parsedate_simple(traverse(scm, ["checkoutDate"])),
                    )
                )
            elif scm.get("@type", "") == "FoodEstablishmentReservation":
                reservations.append(
                    RestaurantEvent(
                        reservation_number=traverse(scm, ["reservationNumber"]),
                        restaurant_name=traverse(scm, ["reservationFor", "name"]),
                        restaurant_address=traverse(
                            scm, ["reservationFor", "address", "streetAddress"]
                        ),
                        time=parsedate_simple(traverse(scm, ["startTime"])),
                        party=traverse(scm, ["partySize"]),
                    )
                )
            else:
                reservations.append(
                    Notification(
                        "Unknown schema type, {}.  Is it interesting?".format(
                            traverse(scm, "@type")
                        )
                    )
                )
    return reservations


def process_mail(mail):
    reservations = []
    if "schema.org" in mail.body:
        logf.info(
            'Parsing schema in email {} "{}"'.format(
                mail.date, mail.subject[:50] + (mail.subject[50:] and "...")
            )
        )
        reservations += process_schema(mail)
    return reservations


bot = telegram.Bot(token=config["telegram"]["token"])

res = []
for email_account in config["email_accounts"]:
    with imaplib.IMAP4_SSL(email_account["server"]) as M:
        M.login(email_account["username"], email_account["password"])
        if args.inbox_only:
            mailboxes = ["INBOX"]
        else:
            r, mailboxes = M.list()
            if r != "OK":
                logf.error("No mailboxes")
                exit(1)
            mailboxes = [mb.decode("utf-8").split(' "/" ')[1] for mb in mailboxes]
        logf.info("Checking mailboxes {}".format(mailboxes))
        for mailbox in mailboxes:
            logf.info("Checking mailbox {}".format(mailbox))
            resp, _ = M.select(mailbox, readonly=True)
            if resp != "OK":
                logf.warn(
                    "Could not select mailbox %s in account %s",
                    mailbox,
                    email_account["name"],
                )
                continue
            r, data = M.search(
                None, '(SINCE "{}")'.format(check_since.strftime("%d-%b-%Y"))
            )
            for message_uid in data[0].decode("utf-8").split():
                r, data = M.fetch(message_uid, "(RFC822)")
                try:
                    em = mailparser.parse_from_bytes(data[0][1])
                except:
                    continue
                res += process_mail(em)


def get_response():
    updates = bot.getUpdates(allowed_updates=["callback_query"])
    if updates != []:
        next_id = updates[-1].update_id + 1
    else:
        next_id = None
    while True:
        try:
            updates = bot.getUpdates(
                offset=next_id, timeout=10, allowed_updates=["callback_query"]
            )
        except telegram.error.TimedOut:
            continue
        if updates != []:
            return updates


menu = [
    [telegram.InlineKeyboardButton(text="Yes, please.", callback_data="yes")],
    [telegram.InlineKeyboardButton(text="No, thank you.", callback_data="no")],
]
reply_markup = telegram.InlineKeyboardMarkup(menu)
for r in res:
    t = r.telegram()
    if t is None:
        continue
    message_id = bot.sendMessage(
        chat_id=config["telegram"]["chat_id"],
        text=t,
        reply_markup=reply_markup,
        parse_mode=telegram.ParseMode.MARKDOWN,
    ).message_id
    response = get_response()[-1]
    bot.answerCallbackQuery(response.callback_query.id)
    bot.editMessageReplyMarkup(
        chat_id=config["telegram"]["chat_id"],
        message_id=message_id,
        reply_markup=telegram.InlineKeyboardMarkup([[]]),
    )
    if response.callback_query.data == "yes":
        personal_calendar.add_event(r.ical())
    else:
        pass
